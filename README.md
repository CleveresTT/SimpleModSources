## Разработка модов на Minecraft 1.12.2
Содержание данного репозитория составлено в формате руководства по разработке модов на Minecraft с версией 1.12.2. Почти в каждой версии Minecraft Forge вводит обновления в свое API и иногда достаточно серьезные. Процесс моддинга в 1.7, 1.12 и 1.14 и выше довольно сильно отличается, поэтому все нижесказанное будет в полной мере справедливо только для версии 1.12. 

Сейчас я рассмотрю требуемый софт, настройку рабочего пространства для моддинга, сборку готового мода, а также структуру проекта небольшого демонстрационного мода, используемые в нем классы, функции и прочие компоненты.
Данное руководство я постарался составить максимально информативно, что, я надеюсь, даже пятиклассник с базовыми знаниями джавы сможет сам сделать свой мод. А также чтобы заинтересованные лица не наступали на те же грабли, что и я. 

### Требуемый софт
Конечно, понадобится сам майнкрафт и чтобы он вообще запускался на компьютере, понадобится java, любой версии, также она понадобится для работы JDK. Думаю, у тех, кому это интересно, данный софт уже есть.
Далее понадобится JDK, чтобы можно было писать код на джаве, причем для версии 1.12 лучше использовать именно восьмую версия. При установке JDK с официального не перепутайте версию и разрядность.

![image](https://user-images.githubusercontent.com/49534873/146041965-1639725b-de24-4b0e-9a70-61cd4f575b55.png)
 
Понадобится установить IDE для программирования на джаве, лучше всего IntelliJ IDEA или Eclipse. Настройка проекта отличается в зависимости от выбранной IDE, я буду использовать и рассматривать IntelliJ IDEA.

Следует объявить переменную среды JAVA_HOME и передать туда путь до установленного JDK. Это нужно для того, чтобы IntelliJ IDEA сам нашел и корректно использовал JDK.

![image](https://user-images.githubusercontent.com/49534873/146042388-b49cb3df-b601-40f4-b9da-bd2d4e512b8b.png)

Нужно установить Minecraft Forge Installer для самой игры, чтобы можно было играть с модами, которые написаны на фордже, а также MDK, который и предоставляет необходимое рабочее пространство. В этот набор включен Gradle – система автоматической сборки, которая и будет проводить всю необходимую конфигурацию, подключать требуемые зависимости, включая исходный код майнкрафта и собирать готовый мод.

![image](https://user-images.githubusercontent.com/49534873/146042423-1dca2580-1a76-4b86-9bc8-e5d2e8ef7d19.png)

Теперь о самом фордже, он представляет собой фреймворк, с помощью которого процесс создания мода сильно упрощается. Я не проверял, насколько сложнее создать мод без его использования, но я склонен доверять статистике, и статистика такова, что 99% модов написано на фордже (или на новомодном Factory). Думаю, это не спроста. 
Кроме автоматической сборки, фордж предоставляет свое API, а также определенные требования к структуре проекта, благодаря чему программисту не нужно задумываться о том, как соединять между собой различные компоненты мода и над многими другими вещами. Таким образом программист полностью сосредоточен на написании логики мода.

### Рабочее пространство и структура проекта

Начать следует с создания где-нибудь пустой папки, в которую переместить из скаченного архива MDK папку gradle и файл build.gradle, можно переместить все, но не нужно. Далее открыть эту папку в IntelliJ IDEA. Gradle сразу же начнет инициализацию проекта и загрузит все необходимые файлы и каталоги. 
После открытия проекта нужно убедится, чтобы в структуре проекта CDK указывал на установленный JDK

  ![image](https://user-images.githubusercontent.com/49534873/146042738-deab4ca5-5f1c-4348-a59e-64cb755ed7b1.png)

  ![image](https://user-images.githubusercontent.com/49534873/146042758-bd7bc469-c32f-4839-821b-e250c222041e.png)

Далее нужно создать папку src. Вы можете использовать мою папку. Именно в ней будет проводится вся работа, в ней также должна быть строго определенная структура каталогов:

![image](https://user-images.githubusercontent.com/49534873/146042937-d73e8e79-3872-4141-8ec0-1c0600d3f6ba.png)
 
Gradle будет просматривать содержимое папки main и включать его в готовую сборку. В папке java находится весь джава-код с классами. В папке resources будут располагаться ресурсы мода, в основном в виде json-файлов, подробнее они будет рассмотрено далее.  

После создания папки src и наполнения его каким-либо содержимым, можно запустить сборку мода. Для этого в Edit Configurations нужно добавить новую конфигурацию -> Gradle -> и выбрать задачу build.

![image](https://user-images.githubusercontent.com/49534873/146043546-e53a16e7-8f65-4380-9cc1-8f6631eab099.png)

![image](https://user-images.githubusercontent.com/49534873/146043561-3bcccf93-3f96-438d-a705-e9fecf903711.png)

При запуске через несколько секунд сборка завершится и по пути *корневая папка мода*\build\libs появится jar-файл, который можно перетащить в AppData\Roaming\.minecraft\mods. На этом установка нового мода завершится, можно будет запустить игру и посмотреть на результат.

### Разработка мода, основные классы
Теперь, когда все организационные моменты обговорены, можно приступить к внутренностям мода. 

**Следующая часть руководства предполагает, что вы настроили рабочее пространство, скачали мой небольшой мод, собрали его, установили в игру и проверили работоспособность. При описании в этом руководстве файлов, классов и каталогов, следует на них посмотреть**

Я начну с файла `mcmod.info`, этот файл предоставляет информацию о моде, которую можно посмотреть в игре, несет просто информативный смысл:

![image](https://user-images.githubusercontent.com/49534873/146044242-9b6b85ba-b2a7-4948-893a-2b6b5d98f871.png)
 
Теперь переходим к основному классу мода - `Main.java`.
 
Forge знает, что это главный класс мода благодаря аннотации `@Mod`, через нее в класс также поступает необходимая информация непосредственно для работы мода, в частности именно здесь указываются его версия, название и идентификатор. 
Очевидно, идентификаторы модов в текущей сборке не должны повторятся, иначе майнкрафт не запустится, или же он не запустится из-за несовпадения версии игры и версии, на которую мод рассчитан. Эти данные можно занести либо харкодом, либо лучше из дополнительного модуля `Data.java`, в котором можно хранить всю глобальную информацию, которая необходима во всем проекте, например `MOD_ID` понадобится указывать не только в главном классе.

В классе `Main.java` указано поле для вкладки в креативе, инстанс мода (обычно оно используется другими модами), а также поле типа `CommonProxy` и методы preInit, init, postInit.
 
Пришло время разобрать немного теории. Forge загружает моды в 3 стадии: преинициализация, инициализация и постинициализация, стадии загрузки мода могут использоваться только в его главном файле. Стадии загрузки можно использовать при помощи аннотации @EventHandler. 
Преинициализация используется для того, чтобы дать игре знать о том, что есть в моде: блоках, предметах и так далее. В частности, у меня происходит их регистрация, а также создание вкладки в креативе и запуск OBJLoader для прорисовки obj моделей. 
Инициализации предназначена для выполнения действий с объектами, зарегистрированными в преинициализации. В частности, у меня происходит регистрация рецептов в печке.
На стадии постинициализации рекомендуется выполнять действия, связанные с другими модами. Я ее не использую.
Кроме стадий инициализации важно понимать и то, что Minecraft состоит из нескольких частей:
Физический клиент — это программа, которая запускается с помощью лаунчера.
Физический сервер — это программа, которая запускается с помощью файлов типа minecraft_server.jar и выключает сервер для многопользовательской игры.
Логический клиент отвечает за отображение моделей и текстур, за прием данных от мышки и клавиатуры, за отображение GUI.
Логический сервер отвечает за всю игровую логику: спавн мобов, погоду, обновление инвентарей, AI и все другие механики игры.
Логические клиент и сервер запускаются вместе с физическим клиентом и понимаются под сторонами клиента и сервера.
Не стоит отрисовывать модели на стороне сервера или регистрировать изменения в мире на стороне клиента. 
Для разделения этих действий для разных сторон, объявление поля proxy в главном классе мода происходит с помощью аннотации @SidedProxy. Таким образом, если мод будет загружен на стороне сервера, то он создаст поле типа CommonProxy, на стороне клиента поле будет типа ClientProxy, который наследуется от CommonProxy. То есть в данном примере CommonProxy выполняет одновременно роль прокси для сервера, и еще роль интерфейса. В крупных модах, которые выполняют много логики на обоих сторонах, специально создают модуль ServerProxy, а CommonProxy используется только как интерфейс.
Можно заметить, что у меня методы preInit, init, postInit почти ничего не делают, однако многие ивенты благодаря Forge сами обрабатываются на нужной стороне, без необходимости явно это регистрировать в этих методах.
***подробнее на демонстрации рассмотрел классы SimpleMod ClientProxy и CommonProxy***

