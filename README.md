## Разработка модов на Minecraft 1.12.2
Содержание данного репозитория составлено в формате руководства по разработке модов на Minecraft с версией 1.12.2. Почти в каждой версии Minecraft Forge вводит обновления в свое API и иногда достаточно серьезные. Процесс моддинга в 1.7, 1.12 и 1.14 и выше довольно сильно отличается, поэтому все нижесказанное будет в полной мере справедливо только для версии 1.12. 

Сейчас я рассмотрю требуемый софт, настройку рабочего пространства для моддинга, сборку готового мода, а также структуру проекта небольшого демонстрационного мода, используемые в нем классы, функции и прочие компоненты.
Данное руководство я постарался составить максимально информативно, что, я надеюсь, даже пятиклассник с базовыми знаниями джавы сможет сам сделать свой мод. А также чтобы заинтересованные лица не наступали на те же грабли, что и я. 

### Требуемый софт
Конечно, понадобится сам майнкрафт и чтобы он вообще запускался на компьютере, понадобится java, любой версии, также она понадобится для работы JDK. Думаю, у тех, кому это интересно, данный софт уже есть.
Далее понадобится JDK, чтобы можно было писать код на джаве, причем для версии 1.12 лучше использовать именно восьмую версия. При установке JDK с официального не перепутайте версию и разрядность.

![image](https://user-images.githubusercontent.com/49534873/146041965-1639725b-de24-4b0e-9a70-61cd4f575b55.png)
 
Понадобится установить IDE для программирования на джаве, лучше всего IntelliJ IDEA или Eclipse. Настройка проекта отличается в зависимости от выбранной IDE, я буду использовать и рассматривать IntelliJ IDEA.

Следует объявить переменную среды JAVA_HOME и передать туда путь до установленного JDK. Это нужно для того, чтобы IntelliJ IDEA сам нашел и корректно использовал JDK.

![image](https://user-images.githubusercontent.com/49534873/146042388-b49cb3df-b601-40f4-b9da-bd2d4e512b8b.png)

Нужно установить Minecraft Forge Installer для самой игры, чтобы можно было играть с модами, которые написаны на фордже, а также MDK, который и предоставляет необходимое рабочее пространство. В этот набор включен Gradle – система автоматической сборки, которая и будет проводить всю необходимую конфигурацию, подключать требуемые зависимости, включая исходный код майнкрафта и собирать готовый мод.

![image](https://user-images.githubusercontent.com/49534873/146042423-1dca2580-1a76-4b86-9bc8-e5d2e8ef7d19.png)

Теперь о самом фордже, он представляет собой фреймворк, с помощью которого процесс создания мода сильно упрощается. Я не проверял, насколько сложнее создать мод без его использования, но я склонен доверять статистике, и статистика такова, что 99% модов написано на фордже (или на новомодном Factory). Думаю, это не спроста. 
Кроме автоматической сборки, фордж предоставляет свое API, а также определенные требования к структуре проекта, благодаря чему программисту не нужно задумываться о том, как соединять между собой различные компоненты мода и над многими другими вещами. Таким образом программист полностью сосредоточен на написании логики мода.

### Рабочее пространство и структура проекта

Начать следует с создания где-нибудь пустой папки, в которую переместить из скаченного архива MDK папку gradle и файл build.gradle, можно переместить все, но не нужно. Далее открыть эту папку в IntelliJ IDEA. Gradle сразу же начнет инициализацию проекта и загрузит все необходимые файлы и каталоги. 
После открытия проекта нужно убедится, чтобы в структуре проекта CDK указывал на установленный JDK

  ![image](https://user-images.githubusercontent.com/49534873/146042738-deab4ca5-5f1c-4348-a59e-64cb755ed7b1.png)

  ![image](https://user-images.githubusercontent.com/49534873/146042758-bd7bc469-c32f-4839-821b-e250c222041e.png)

Далее нужно создать папку src. Вы можете использовать мою папку. Именно в ней будет проводится вся работа, в ней также должна быть строго определенная структура каталогов:

![image](https://user-images.githubusercontent.com/49534873/146042937-d73e8e79-3872-4141-8ec0-1c0600d3f6ba.png)
 
Gradle будет просматривать содержимое папки main и включать его в готовую сборку. В папке java находится весь джава-код с классами. В папке resources будут располагаться ресурсы мода, в основном в виде json-файлов, подробнее они будет рассмотрено далее.  

После создания папки src и наполнения его каким-либо содержимым, можно запустить сборку мода. Для этого в Edit Configurations нужно добавить новую конфигурацию -> Gradle -> и выбрать задачу build.

![image](https://user-images.githubusercontent.com/49534873/146043546-e53a16e7-8f65-4380-9cc1-8f6631eab099.png)

![image](https://user-images.githubusercontent.com/49534873/146043561-3bcccf93-3f96-438d-a705-e9fecf903711.png)

При запуске через несколько секунд сборка завершится и по пути *корневая папка мода*\build\libs появится jar-файл, который можно перетащить в AppData\Roaming\.minecraft\mods. На этом установка нового мода завершится, можно будет запустить игру и посмотреть на результат.

### Разработка мода, основные классы
Теперь, когда все организационные моменты обговорены, можно приступить к внутренностям мода. 

` **Следующая часть руководства предполагает, что вы настроили рабочее пространство, скачали мой небольшой мод, собрали его, установили в игру и проверили работоспособность. При описании в этом руководстве файлов, классов и каталогов, следует на них посмотреть** `

Я начну с файла `mcmod.info`, этот файл предоставляет информацию о моде, которую можно посмотреть в игре, несет просто информативный смысл:

![image](https://user-images.githubusercontent.com/49534873/146044242-9b6b85ba-b2a7-4948-893a-2b6b5d98f871.png)
 
Теперь переходим к основному классу мода - `Main.java`.
 
Forge знает, что это главный класс мода благодаря аннотации `@Mod`, через нее в класс также поступает необходимая информация непосредственно для работы мода, в частности именно здесь указываются его версия, название и идентификатор. 
Очевидно, идентификаторы модов в текущей сборке не должны повторятся, иначе майнкрафт не запустится, или же он не запустится из-за несовпадения версии игры и версии, на которую мод рассчитан. Эти данные можно занести либо харкодом, либо лучше из дополнительного модуля `Data.java`, в котором можно хранить всю глобальную информацию, которая необходима во всем проекте, например `MOD_ID` понадобится указывать не только в главном классе.

В классе `Main.java` указано поле для вкладки в креативе, инстанс мода (обычно оно используется другими модами), а также поле типа `CommonProxy` и методы preInit, init, postInit.
 
Пришло время разобрать немного теории. Forge загружает моды в 3 стадии: преинициализация, инициализация и постинициализация, стадии загрузки мода могут использоваться только в его главном файле. Стадии загрузки можно использовать при помощи аннотации `@EventHandler`. 

Преинициализация используется для того, чтобы дать игре знать о том, что есть в моде: блоках, предметах и так далее. В частности, у меня происходит их регистрация, а также создание вкладки в креативе и запуск OBJLoader для прорисовки obj моделей. 

Инициализации предназначена для выполнения действий с объектами, зарегистрированными в преинициализации. В частности, у меня происходит регистрация рецептов в печке.

На стадии постинициализации рекомендуется выполнять действия, связанные с другими модами. Я ее не использую.

Кроме стадий инициализации важно понимать и то, что Minecraft состоит из нескольких частей:
- Физический клиент — это программа, которая запускается с помощью лаунчера.
- Физический сервер — это программа, которая запускается с помощью файлов типа minecraft_server.jar и выключает сервер для многопользовательской игры.
- Логический клиент отвечает за отображение моделей и текстур, за прием данных от мышки и клавиатуры, за отображение GUI.
- Логический сервер отвечает за всю игровую логику: спавн мобов, погоду, обновление инвентарей, AI и все другие механики игры.

Логические клиент и сервер запускаются вместе с физическим клиентом и понимаются под сторонами клиента и сервера.
Не стоит отрисовывать модели на стороне сервера или регистрировать изменения в мире на стороне клиента. 

Для разделения этих действий для разных сторон, объявление поля `proxy` в главном классе мода происходит с помощью аннотации `@SidedProxy`. Таким образом, если мод будет загружен на стороне сервера, то он создаст поле типа `CommonProxy`, на стороне клиента поле будет типа `ClientProxy`, который наследуется от `CommonProxy`. То есть в данном примере `CommonProxy` выполняет одновременно роль прокси для сервера, и еще роль интерфейса. В крупных модах, которые выполняют много логики на обоих сторонах, специально создают модуль `ServerProxy`, а `CommonProxy` используется только как интерфейс.

Можно заметить, что у меня методы preInit, init, postInit почти ничего не делают, однако многие ивенты благодаря Forge сами обрабатываются на нужной стороне, без необходимости явно это регистрировать в этих методах.

### Кастомная вкладка в креативе
Начну с самого простого класса. Зарегистрированные предметы можно получить либо с помощью команды `/give @p *MODID*:*Регистрируемое имя предмета*`, либо из вкладки в креативе, что намного удобнее. В частности, для мода можно сделать свою собственную вкладку, описанную в классе `CreativeTabMod.java`

Подавляющая часть функционала модов основана на существующих классах в исходном коде майнкрафта. Здесь класс кастомной вкладки в креативе создается путем наследования от готового класса `CreativeTabs`. 

В моем классе есть конструктор, который срабатывает при создании нового инстанса этого класса в стадии преинициализации. Первым параметром передается значение `CreativeTabs.getNextID()`, которое возвращает идентификатор этой вкладки после загрузки предыдущих ванильных вкладок, или после загрузки других модов, вторым параметром передается регистрируемое имя, далее с помощью ключевого слова `super` вызывается конструктор `CreativeTabs` и создается новая вкладка с переданными параметрами. 
Чтобы у этой вкладки была иконка, вызывается функция `getTabIconItem`, данный метод возвращает иконку предмета, в данном случае возвращается иконка рубина. Аннотация `@Override` нужна для перезаписи этой функции внутри `CreativeTabs`.

### Рецепты в печке
 
В классе `ModSmelting.java` определен только метод init, который вызывается в стадии инициализации. Я добавил два рецепта через `GameRegistry.addSmelting()`, этот метод регистрирует рецепт в печке с определенными параметрами. 
Первый параметр – это блок или предмет, который подлежит обработке в печке. Второй параметр – это объект `ItemStack`, ячейка в инвентаре с предметами, у него есть свои параметры: определенный блок или предмет, а также количество полученного объекта. Третий параметр – это количество опыта, которое получает игрок после процесса обработки предмета.
Первый рецепт превратит рубиновый блок в алмазный и даст полторы единицы опыта, а второй превратит один алмаз в два рубина и даст три единицы опыта.

### Создание и регистрация предметов
 
Несмотря на объемность класса `ModItems.java`, тут все очень просто. Первое поле `ITEM`S является динамическим списком, в котором хранятся объекты типа `Item`. Именно в него добавляются все создаваемые предметы и блоки в моде, и он используется для их регистрации в игре и отрисовки их моделей. Здесь просто по очереди создаются новые предметы типов `ItemBase`. `ToolSword`, `ToolSpade`, `ToolPickaxe`, `ToolAxe`, `ToolHoe`, `CustomSword`, `ArmorBase`. Эти классы рассмотрю позднее. 

Кроме этого, здесь идет определение материала для брони и инструментов через методы EnumHelper. Именно параметры этих материалов влияют на качества предметов, при этом параметр текстуры брони влияет и на то, как она будет выглядеть в игре. Например, параметры ванильных предметов такие:

![image](https://user-images.githubusercontent.com/49534873/146047455-9153979e-7ae4-492c-be85-558ddd6ed3ba.png)

![image](https://user-images.githubusercontent.com/49534873/146047466-7562998a-0df0-4500-b957-7a4984efaa0e.png)
  
По сути, этот класс является хранилищем для всех предметов в моде, и для того, чтобы добавить новый, достаточно внести новое поле именно сюда. Регистрация и присвоение модели происходит в конструкторах классов, перечисленных мной ранее.

### Предметы
 
`ItemBase.java` является базовым классом для создания обычных предметов в моде. Первая функция `setUnlocaliziedName` в конструкторе задает имя предмета в формате `item.*регистрируемое имя*.name`, оно далее пригодится для локализации. Вторая функция `setRegistryName` задает само регистрируемое имя в моде в формате `modid:*регистрируемое имя*`. Третья функция `setCreativeTab` добавляет предмет в конец стека заданной вкладки креатива. Четвертая операция добавляет предмет в список `ITEMS`, принадлежащий рассмотренному ранее классу `ModItems`.

Теперь перейдем к классу брони `ArmorBase`. Тут все то же самое, что и в предыдущем классе, только этот наследуется от класса `ItemArmor`, определенного в коде игры, а ключевое слово super используется для вызова конструктора этого класса, соответственно конструктор `ArmorBase` получает инстанс родительского класса, дополняет и преобразует его для использования в моде.

Теперь к классам инструментов: `ToolSword`, `ToolSpade`, `ToolPickaxe`, `ToolAxe`, `ToolHoe`.
Такая же картина, как и в `ArmorBase`, только они наследются от соответствующих себе классов и в классе `ToolAxe` я еще продемонстрировал возможность перезаписывать параметры, переданные с материалом. 
 
Предметы, созданные с помощью класса `CustomSword` будут загружаться во вкладку креатива, принадлежащей самому моду, а также я добавил обработку события `onItemUse`, которое срабатывает при нажатии ПКМ предметом этого класса. Когда я запускаю это событие, используя меч при наведении на блок травы, он заменяется на блок песка душ, а также проигрывается звуковой эффект выстрела иссушителя, звук слышен только рядом с тем игроком, который запустил это событие.

### Блоки
 
Класс `ModBlocks` для хранения блоков мода, аналогичный классу `ModItems`.

Базовый класс `BlockBase` для создания блоков мода, аналогичный классу `ItemBase`, только, кроме того, чтобы добавить блок в поле `BLOCKS`, требуется добавить предмет блока типа `ItemBlock` в поле `ITEMS`, чтобы вместе с остальными предметами зарегистрировать блок и присвоить ему модельку.

`RubyBlock` - это класс рубинового блока, который наследуется от `BlockBase`. В конструкторе этого класса блок наделяется свойствами, например рубиновому блоку присваивается звуковой эффект металлических блоков, твердость, сопротивляемость взрывам, светимость и уровень добычи – второй уровень соответствует тому, что такой блок можно добыть только железной киркой или лучше (третий уровень соответствует обсидиановому блоку, который можно добыть только алмазной киркой).
Так же я добавил обработку событий. Если игрок поставит рубиновый блок, то в игрока ударит молния, а также он получит эффект регенерации четвертого уровня на 100 тиков, что эквивалентно пяти секундам (в майнкрафте тик – это минимальный промежуток времени и в одной секунде 20 тиков). А еще, если кто-то наступит на этот блок и будет по нему ходить, то это существо загорится на три секунды.
 
`MatrixBlock` - это класс блока матрицы, который выглядит как метраллический стол, для него присвоен звуковой тип наковальни, а также игрок не сможет его разрушить. Однако я не задал матрице устойчивость к взрывам, и даже добавил обработку события, когда она разрушается от взрыва, например, если рядом взорвется ТНТ. При срабатывании этого события, на месте разрушенной матрицы создается еще один взрыв, причем с силой 30 (а у ТНТ сила взрыва равна четырем). 
Метод `isOpaqueCube` нужен, чтобы определить непрозрачность блока. Если у блока есть своя OBJ моделька, то нужно сделать блок прозрачным, задав значение false, иначе будет возникать эффект X-Ray при просмотре через него.

### Регистрация предметов и загрузка моделей
 
Вернемся в `ClientProxy`, аннотация `@EventBusSubscriber` нужна для автоматической регистрации статических методов – обработчиков событий, именно они будут регистрировать предметы и загружать модели. В этой аннотации я явно указываю идентификатор мода, чтобы обработчики в этом классе не конфликтовали с обработчиками из других модов, а также сторону, на которой они будут работать – клиентскую. Обработчики обязательно должны быть статическими.

Аннотация `@SubscribeEvent` указывает на то, что данный метод будет вызываться при срабатывании события определенного типа. 
Первые два метода вызываются при событии `RegistryEvent.Register<T>`, которое срабатывает при создании инстанса переданного в шаблон типа(В моем случае это типы `Item` и `Block`), в этих методах через `event.getRegistry().registerAll()` загружаются все объекты из массивов `ITEMS` и `BLOCKS`. Блоги регистрируются в два этапа.

Третий обработчик вызывается при событии `ModelRegistryEvent`, которое срабатывает после регистрации всех предметов. В нем происходит итерация по массиву `ITEMS`, Метод `ModelLoader.setCustomModelResourceLocation()` принимает в качестве параметров предмет, метаданные и расположение ресурса в формате `modid:*регистрируемое имя*`. Он выполняет сложную логику поиска json-файла в каталоге ресурсов, и теперь самое время перейти к нему.

### Ресурсы мода
Наконец, все классы, используемые в моде, рассмотрены. В каталоге с классами не требуется придерживаться какой-либо структуры папок и файлов, а вот в каталоге с ресурсами структура должна быть строго определенной, иначе игра просто не сможет найти нужный ресурс, так как нигде не указываются прямые пути до них. Внутри папки `assets` находится папка `tm`, которая соответствует идентификатору мода.
В папке `lang` находятся файлы с локализацией под разные языки. В них нелокализованным именам присваивается более читаемое людьми имя. При этом нельзя ставить нигде лишние пробелы.
 
При рассмотрении оставшихся ресурсов, нужно иметь ввиду, что регистрируемые имена предметов и блоков должны совпадать с названиями файлов, соответствующими им.
В папке `recipes` находятся рецепты для сетки крафта в виде json. 

Рецепт рубина - `ruby.json`.
Поле тип может иметь два значения: `shape` и `shapless`. Если задан тип `shapless`, то расположение ингредиентов крафта в сетке не имеет значения. Поле `Ingredients` задает массив этих самых ингредиентов, у меня это один алмаз и три яблока. Поле `result` определяет результат крафта – один рубин.

Рецепт кастомного меча - `lotr_sword_1.json`. 
Если задан тип `shape`, то вместо поля `Ingredients` нужно определить поля `pattern` и `key`. В поле pattern указываются символы, которые определяются элементами поля `key`. Теперь имеет значение, какие предметы должны располагаться в сетке и в каких местах.

В папке `blockstates` хранятся json-ки, которые определяют состояния блоков и состояния предметов (не только блоков), которые загружают obj-файлы. У каждого блока и у каждой кастомной модели должна быть json-ка в этой папке. У обычного блока(`ruby_block.json`) достаточно только в нормальном варианте указать загружаемую модель, которая находится в папке `models`. 
Для json-ок кастомных блоков(`matrix.json`) структура строки намного сложнее. `forge_marker` нужен для того, чтобы разрешить загрузку obj-модели. В `defaults` определяются текстуры, кусочки, вылетающие из блока при его повреждении, `flip-v` нужен потому, что Blender и Forge не согласованы в расположении вертикальной координатой текстуры, поэтому ее нужно перевернуть. Это нужно только для моделей, которые экспортируются из Blender. В `variants` определяется сама моделька, а также ее расположение в мире и в инвентаре. Для json-ок кастомных предметов(`lotr_sword_1.json`) в `defaults` определяется расположение предмета.

В папке `models` у меня есть папки `block` и `item`. Рассмотрю сначала папку `block`. Для модели обычного блока(`ruby_block.json`) в json-ке достаточно задать путь до родительской модели из самой игры и путь до текстуры. Для того, чтобы загрузить кастомную модель(`matrix.obj` и `matrix.mtl`) нужно расположить obj-файлы именно в каталоге models, без дополнительной json-ки, так как вся необходимая информация уже была изложена для этой модели в соответствующей json-ке в папке `blockstates`, кроме того, откуда и как загружать текстуры. Для этого нужен mtl-файл, который прилагается к obj.

В папке `item` указываются модельки предметов. Для кастомных моделей(`lotr_sword_1.json`) правила такие же – пара obj и mtl. Для обычных блоков тоже нужно здесь задать модельку, только достаточно просто указать в поле `parent` путь до той json-ки в папке `block`, которую я разбирал только что. Для обычных плоских предметов тоже достаточно просто указать пути до родительской модели из игры и текстуры
В папке `textures` находятся еще три папки `blocks`, `items` и `models`. В первых двух просто хранятся текстуры в формате png. В папке `models` есть еще одна папка `armor`, в которой материалы брони ищут для себя развертки текстур. Префиксы, заданные в параметрах материала брони в классе `ModItems` и в названии файла с текстурой должны совпадать.

### Заключение
В заключение хочу отметить, что реализация мода не должна быть точно такой же, как я описал. Например, регистрация и присвоение моделей может происходить совсем иначе от мода к моду. 

При продумывании нового функционала для своего мода обязательно нужно просматривать классы и функции в исходном коде игры с помощью комбинации `ctrl+ЛКМ`, и пользоваться исходным кодом как документацией.

Очень распространенным приемом для разработки модов конечно же является просмотр исходников других модов. Используя IntelliJ IDEA, не нужно даже искать репозиторий с исходниками от автора интересующего мода, достаточно скачать мод, заглянуть в его архив и открыть в IntelliJ IDEA классы мода. Эти классы при сборке мода становятся нечитаемыми для человека, но IntelliJ IDEA генерирует из них читаемый код, в котором можно посмотреть на реализацию интересующего функционала. 
Именно при просмотре чужих модов можно заметить, как моды одной и той же версии отличаются друг от друга, а также посмотреть на их объем – десяток тысяч строк кода и сотня классов.

Мой мод был чисто демонстрационным и экспериментальным, в котором я реализовал только основной функционал, общий для большинства модов.

